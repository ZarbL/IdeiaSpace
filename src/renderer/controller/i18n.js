// i18n.js - Gerenciador de tradu√ß√£o para IdeiaSpace

const i18n = {
  current: localStorage.getItem('language') || 'pt-BR',
  translations: {},
  
  async loadTranslations(lang) {
    try {
      const response = await fetch(`../locales/${lang}.json`);
      if (!response.ok) throw new Error('Falha ao carregar tradu√ß√µes');
      this.translations[lang] = await response.json();
      console.log(`‚úÖ Tradu√ß√µes carregadas para ${lang}:`, Object.keys(this.translations[lang]).length, 'chaves');
    } catch (e) {
      console.error('‚ùå Erro ao carregar tradu√ß√µes:', e);
      this.translations[lang] = {};
    }
  },
  
  t(key) {
    const lang = this.current;
    return (this.translations[lang] && this.translations[lang][key]) ? this.translations[lang][key] : key;
  },
  
  async setLanguage(lang) {
    console.log(`üåê Mudando idioma para: ${lang}`);
    console.log(`üìä Tradu√ß√µes dispon√≠veis:`, Object.keys(this.translations));
    
    if (!this.translations[lang]) {
      console.log(`‚ö†Ô∏è Tradu√ß√£o n√£o carregada para ${lang}, tentando carregar...`);
      await this.loadTranslations(lang);
    }
    if (this.translations[lang]) {
      console.log(`‚úÖ Definindo idioma atual como: ${lang}`);
      this.current = lang;
      localStorage.setItem('language', lang);
      
      console.log('üîÑ Aplicando tradu√ß√µes...');
      this.applyTranslations();
      
      console.log('üîÑ Atualizando blocos Blockly...');
      this.updateBlocklyBlocks();
      
      console.log('üîÑ Atualizando categorias do toolbox...');
      this.updateToolboxCategories();
      
      // Disparar evento customizado para outros componentes
      console.log('üì° Disparando evento languageChanged...');
      window.dispatchEvent(new CustomEvent('languageChanged', { 
        detail: { language: lang, translations: this.translations[lang] } 
      }));
      
      console.log('‚úÖ Processo de mudan√ßa de idioma conclu√≠do!');
    } else {
      console.error(`‚ùå N√£o foi poss√≠vel carregar tradu√ß√µes para: ${lang}`);
    }
  },
  
  applyTranslations() {
    const lang = this.current;
    console.log(`üîÑ Aplicando tradu√ß√µes para: ${lang}`);
    
    // Elementos com data-translate-key
    const elementsToTranslate = document.querySelectorAll('[data-translate-key]');
    console.log(`üìã Encontrados ${elementsToTranslate.length} elementos para traduzir`);
    
    elementsToTranslate.forEach(el => {
      const key = el.getAttribute('data-translate-key');
      if (key && this.translations[lang] && this.translations[lang][key]) {
        const oldText = el.textContent;
        const newText = this.translations[lang][key];
        el.textContent = newText;
        console.log(`üîÑ Traduzido "${key}": "${oldText}" ‚Üí "${newText}"`);
      } else {
        console.warn(`‚ö†Ô∏è Tradu√ß√£o n√£o encontrada para chave "${key}" no idioma ${lang}`);
      }
    });
    
    // Elementos com data-translate-key-placeholder para placeholders
    const placeholderElements = document.querySelectorAll('[data-translate-key-placeholder]');
    console.log(`üìã Encontrados ${placeholderElements.length} placeholders para traduzir`);
    
    placeholderElements.forEach(el => {
      const key = el.getAttribute('data-translate-key-placeholder');
      if (key && this.translations[lang] && this.translations[lang][key]) {
        el.placeholder = this.translations[lang][key];
        console.log(`üîÑ Placeholder traduzido "${key}"`);
      }
    });
    
    // Tooltips
    const tooltipElements = document.querySelectorAll('[data-tooltip-key]');
    console.log(`üìã Encontrados ${tooltipElements.length} tooltips para traduzir`);
    
    tooltipElements.forEach(el => {
      const key = el.getAttribute('data-tooltip-key');
      if (key && this.translations[lang] && this.translations[lang][key]) {
        el.setAttribute('data-tooltip', this.translations[lang][key]);
        console.log(`üîÑ Tooltip traduzido "${key}"`);
      }
    });
    
    // Atualizar t√≠tulo da p√°gina
    const pageTitle = document.getElementById('pageTitle');
    if (pageTitle) {
      pageTitle.textContent = this.t('pageTitle');
      console.log(`üîÑ T√≠tulo da p√°gina atualizado: "${pageTitle.textContent}"`);
    }
    
    // Atualizar cabe√ßalho do c√≥digo
    const codeHeader = document.getElementById('codeHeader');
    if (codeHeader) {
      codeHeader.textContent = this.t('cppCodeTitle');
      console.log(`üîÑ Cabe√ßalho do c√≥digo atualizado: "${codeHeader.textContent}"`);
    }
    
    // Atualizar placeholder do c√≥digo
    const codeDisplay = document.getElementById('code-display');
    if (codeDisplay && codeDisplay.textContent.includes('//')) {
      codeDisplay.textContent = this.t('cppCodePlaceholder');
      console.log(`üîÑ Placeholder do c√≥digo atualizado`);
    }
    
    // Atualizar tooltips espec√≠ficos baseados no estado atual
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (darkModeToggle) {
      const body = document.body;
      if (body.classList.contains('dark-mode')) {
        darkModeToggle.setAttribute('data-tooltip', this.t('darkModeTooltipLight'));
      } else {
        darkModeToggle.setAttribute('data-tooltip', this.t('darkModeTooltip'));
      }
    }
    
    console.log(`‚úÖ Tradu√ß√µes aplicadas para ${lang}`);
  },
  
  updateBlocklyBlocks() {
    if (typeof Blockly === 'undefined' || !Blockly.Blocks) {
      console.log('‚ö†Ô∏è Blockly n√£o dispon√≠vel para tradu√ß√£o de blocos');
      return;
    }
    
    console.log('üîÑ Atualizando tradu√ß√µes dos blocos Blockly...');
    const lang = this.current;
    
    // Atualizar bloco MPU6050 read se existir
    if (Blockly.Blocks['mpu6050_read']) {
      const originalInit = Blockly.Blocks['mpu6050_read'].init;
      Blockly.Blocks['mpu6050_read'].init = function() {
        originalInit.call(this);
        
        // Atualizar dropdown options
        const dropdown = this.getField('MPU6050_AXIS');
        if (dropdown) {
          const options = [
            [i18n.t('ACCEL_X'), 'ACCEL_X'],
            [i18n.t('ACCEL_Y'), 'ACCEL_Y'],
            [i18n.t('ACCEL_Z'), 'ACCEL_Z'],
            [i18n.t('GYRO_X'), 'GYRO_X'],
            [i18n.t('GYRO_Y'), 'GYRO_Y'],
            [i18n.t('GYRO_Z'), 'GYRO_Z']
          ];
          dropdown.menuGenerator_ = options;
        }
        
        this.setTooltip(i18n.t('mpu6050_read_tooltip'));
      };
    }
    
    // Atualizar outros blocos se necess√°rio
    this.updateCustomBlockTranslations();
  },
  
  updateCustomBlockTranslations() {
    // Fun√ß√£o para atualizar tradu√ß√µes espec√≠ficas dos blocos customizados
    const blocks = [
      'mpu6050_init', 'mpu6050_not', 'bmp180_init', 
      'bmp180_temperature', 'bmp180_pressure', 'bmp180_altitude',
      'delay_function'
    ];
    
    blocks.forEach(blockType => {
      if (Blockly.Blocks[blockType]) {
        const block = Blockly.Blocks[blockType];
        if (block.setTooltip && this.t(`${blockType}_tooltip`)) {
          // Se o bloco j√° foi instanciado, atualizar tooltip
          const instances = workspace ? workspace.getBlocksByType(blockType) : [];
          instances.forEach(instance => {
            instance.setTooltip(this.t(`${blockType}_tooltip`));
          });
        }
      }
    });
  },
  
  updateToolboxCategories() {
    // Esta fun√ß√£o ser√° chamada quando a tradu√ß√£o mudar para atualizar o toolbox
    if (typeof workspace !== 'undefined' && workspace.updateToolbox) {
      console.log('üîÑ Atualizando categorias do toolbox...');
      
      // Buscar o toolbox original
      const originalToolbox = document.getElementById('toolbox');
      if (originalToolbox) {
        // Clonar o toolbox e traduzir as categorias
        const translatedToolbox = this.translateToolbox(originalToolbox.cloneNode(true));
        workspace.updateToolbox(translatedToolbox);
      }
    }
  },
  
  translateToolbox(toolboxElement) {
    // Traduzir nomes das categorias
    const categories = toolboxElement.querySelectorAll('category[name]');
    categories.forEach(category => {
      const originalName = category.getAttribute('name');
      let translationKey = '';
      
      // Mapear nomes para chaves de tradu√ß√£o
      switch(originalName) {
        case 'L√≥gica': 
        case 'Logic': 
          translationKey = 'CAT_LOGIC'; 
          break;
        case 'Controle': 
        case 'Control': 
          translationKey = 'CAT_CONTROL'; 
          break;
        case 'Matem√°tica': 
        case 'Math': 
          translationKey = 'CAT_MATH'; 
          break;
        case 'Texto': 
        case 'Text': 
          translationKey = 'CAT_TEXT'; 
          break;
        case 'Vari√°veis': 
        case 'Variables': 
          translationKey = 'CAT_VARIABLES'; 
          break;
        case 'Fun√ß√µes': 
        case 'Functions': 
          translationKey = 'CAT_FUNCTIONS'; 
          break;
        case 'Tempo': 
        case 'Time': 
          translationKey = 'CAT_TIME'; 
          break;
        case 'Bibliotecas': 
        case 'Libraries': 
          translationKey = 'CAT_LIBRARIES'; 
          break;
        case 'Sensores': 
        case 'Sensors': 
          translationKey = 'CAT_SENSORS'; 
          break;
        case 'MPU6050':
        case 'Medidas Inerciais':
        case 'Inertial Measurements':
          translationKey = 'CAT_MPU6050'; 
          break;
        case 'BMP180':
          translationKey = 'CAT_BMP180'; 
          break;
        case 'BH1750':
          translationKey = 'CAT_BH1750'; 
          break;
        case 'HMC5883':
          translationKey = 'CAT_HMC5883'; 
          break;
        case 'DHT':
          translationKey = 'CAT_DHT'; 
          break;
      }
      
      if (translationKey && this.t(translationKey)) {
        category.setAttribute('name', this.t(translationKey));
      }
    });
    
    // Traduzir bot√µes
    const buttons = toolboxElement.querySelectorAll('button[text]');
    buttons.forEach(button => {
      const originalText = button.getAttribute('text');
      if (originalText.includes('Criar Nova Vari√°vel') || originalText.includes('Create New Variable')) {
        button.setAttribute('text', this.t('createVariableButton'));
      }
    });
    
    return toolboxElement;
  }
};

// Inicializa√ß√£o quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', async function() {
  console.log('üöÄ Inicializando sistema i18n...');
  console.log('üìä Estado inicial do DOM:', document.readyState);
  
  try {
    // Verificar se os elementos necess√°rios existem
    const languageToggle = document.getElementById('languageToggle');
    const languageOptions = document.querySelectorAll('.language-option');
    console.log('üîç Elemento languageToggle encontrado:', !!languageToggle);
    console.log('üîç Op√ß√µes de idioma encontradas:', languageOptions.length);
    
    // Carregar ambos os idiomas
    console.log('üì• Carregando tradu√ß√µes...');
    await i18n.loadTranslations('pt-BR');
    await i18n.loadTranslations('en-US');
    
    console.log('üìä Tradu√ß√µes carregadas:', Object.keys(i18n.translations));
    
    // Definir idioma atual
    console.log('üåê Definindo idioma atual:', i18n.current);
    await i18n.setLanguage(i18n.current);
    
    console.log('‚úÖ Sistema i18n inicializado com sucesso!');
    
    // Disponibilizar globalmente
    window.i18n = i18n;
    console.log('üåç i18n disponibilizado globalmente:', !!window.i18n);
    
    // Testar uma tradu√ß√£o
    console.log('üß™ Teste de tradu√ß√£o para "pageTitle":', i18n.t('pageTitle'));
    
    // Verificar se os elementos HTML est√£o sendo traduzidos
    setTimeout(() => {
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle) {
        console.log('üìù Texto atual do t√≠tulo:', pageTitle.textContent);
      }
    }, 1000);
    
  } catch (error) {
    console.error('‚ùå Erro ao inicializar i18n:', error);
  }
});